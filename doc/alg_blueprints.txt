Ping:Crow Boy Function Blueprints



DRAW SCREEN
This function will draw a part of the current level to screen
; METHOD 1
; 6502 Asm code
; copy level to screen
.0	ldy #39			; 2 cycle
.1	lda (levelPtr), y	; 5
	sta (screenPtr), y	; 6
	tax			; 2
	lda colorData, x	; 4
	sta (colorPtr), y	; 6
	
	dey			; 2
	bpl .1			; 2, 3-4
	clc			; 2    next row of levelPtr, screenPtr, and colorPtr
	lda #40			; 2
	adc screenPtr		; 3
	bcc .2			; 2, 3-4
	inc screenPtr+1		; 5
	inc colorPtr+1		; 5
.2	sta screenPtr		; 3
	sta colorPtr		; 3
	inc levelPtr		; 5
	lda #$5C		; 2    if levelPtr = $5C00, exit loop
	cmp levelPtr		; 3
	bne .0			; 2, 3-4

	rts

28*40*18+7*18+12*2+3*16+18*18 = 20682 cycles


;METHOD 2
; init	lda upperLeft		; 3
	ldy #$4A		; 2
	sta .lPtr+1		; 4
	sty .lPtr+2		; 4
	lda #<(screenPtr-1)	; 2
	ldy #>(screenPtr-1)	; 2
	sta .sPtr+1		; 4
	sty .sPtr+2		; 4
	lda #<(colorPtr-1)	; 2
	ldy #>(colorPtr-1)	; 2
	sta .cPtr+1		; 4
	sty .cPtr+2		; 4

.0	ldx #0			; 2
.1	inc .sPtr+1		; 6
	inc .cPtr+1		; 6
	bne .2			; 2, 3-4
	inc .sPtr+2		; 6
	inc .cPtr+2		; 6
.2:	
.lPtr	lda $FFFF, x		; 4
.sPtr	sta $FFFF		; 4
	tay			; 2
	lda colorData, y	; 4
.cPtr	sta $FFFF		; 4

	inx			; 2
	cpx #40			; 2    if x = 40, do next row
	bne .1			; 2, 3-4

	inc .lPtr+2		; 6     .lPtr += 256;
	lda .lPtr+2		; 4
	cmp #$5C		; 2	  if last row, then exit
	bne .0			; 2, 3-4
	
	rts

2*18 + 12*18*40 + 12*2 + 3*18*40 + 18*18*40 + 4*18*40 + 2*18 + 3*40*18-18 + 12*18 + 3*18 + 2 = 29150


;METHOD 3
; unrolling the loop
;   requires setting up table of pointers to rows in the level.
;   LSBs will all be the same, MSBs are from $4A, $4B, $4C...$5B in increasing order
	ldy #39			; 2 cycle
.1	lda levelPtr1, y	; 4
	sta kScreenPtr1, y	; 4-5
	tax			; 2
	lda kColorData, x	; 4
	sta kColorPtr1, y	; 4-5

	lda levelPtr2, y	; 4
	sta kScreenPtr2, y	; 4-5
	tax			; 2
	lda kColorData, x	; 4
	sta kColorPtr2, y	; 4-5

	; ... etc ...

	lda levelPtr18, y	; 4
	sta kScreenPtr18, y	; 4-5
	tax			; 2
	lda kColorData, x	; 4
	sta kColorPtr18, y	; 4-5

	dey
	bpl .1

	rts

;	((18*18)+2*18)*40 = 14400

; METHOD 4a(best method)
; Setting up another screen, page flip and copying just color
	ldy #39 
.1	lda kOffscrColorPtr1, y	; 4
	sta kColorPtr1, y	; 4-5

	; ... etc ...

	dey
	bpl .1

	rts

;	(8*16+9*2)*40 = 5840
;	Loop very fast, but needs additional space for screen/color data.
;		Also, would have to set aside a refresh for copying data into
;		these offscreens, which would bump the framerate down slightly


; METHOD 4b
; Setting up another screen, no page flip copying color and char data
	ldy #39 
.1	lda kOffscrColorPtr1, y	; 4
	sta kColorPtr1, y	; 4-5
	lda kOffscrChar1, y	; 4
	sta kScreenPtr1, y	; 4-5

	; ... etc ...

	dey
	bpl .1

	rts
;	(16*16+18*2)*40 = 11680
;	Same as METHOD 4a, but wouldn't need to worry about hardware page-flipping


**************************************************************
Handle input
Pseudocode:
void HandleInput()
{
	GetJoystick(&X, &Y, &Fire);
	if (X = 1) RequestAction(0, Run, right);
	else if (X =-1) RequestAction(0, Run, left);
	else RequestAction(0, Stand);
	
	if (Y = 1);
	else if (Y =-1) RequestAction(0, Jump);
	
	if (Fire) RequestAction(0, Attack);
}

**************************************************************
Request action
Possible actions to request:
	Run(left or right)
	Stand
	Jump
	Attack

Pseudocode:
void RequestAction(theObject, theAction, facing)	// this is for characters only
{
	if (theAction == theObject.currentAction) return;
	
	if (theAction == run && theObject.currentAction == stand)
	{
		goto setAction;
	}
	
	if (theAction == stand)
	{
		goto setAction;
	}
	
	if (theAction == jump && (theObject.currentAction != attack))
	{
		theObject.acceleration = -kJumpVelocity;
		goto setAction;
	}
	
	if (theAction == attack)
	{
		goto setAction;
	}
	
	return;

setAction:					// the action has been allowed, so make changes
	theObject.newAction = true;
	theObject.currentAction = theAction;
	theObject.spriteDataPtr = *(theObject.actionArray + theAction);
}

**************************************************************
Updating objects

Pseudocode:
void UpdateObjects()
{
	for(char i=0; i<8; i++)
	{
		if (obj[i].active = false)
			continue;
		
	}
	
};
	
**************************************************************
Screen fade
IRQEnter
  Int_WorldScreenUpdate  \ toggle
  Int_ModeJump      /

  Int_MainMenu


During game:
  

For menu, use fullscreen
For game, fade just the viewport

Fade out:
  Fade each towards black:
    color mem
    border
    background
    multicolors
    sprite colors

Fade in:
  Setup:
    start with all colors black
    copy chars to current screen
  Fade from color mem values towards offscreen color values

**********************************
Order of operation
- fade screen out
- set screen mem to screen 1, charset to chrset 2
- show C64 logo
- init text
- set mode to ExitToMainMenu
- InitIRQ

- irq: IRQEnter (mode ExitToMainMenu)
  - sets interrupt to Int_MainMenu and compare
- irq: Int_MainMenu (menu_mode DrawMenu)
  - set menu_mode to MenuLoop
- irq: Int_MainMenu (menu_mode MenuLoop)
  - set mode to NewGame
  - set_interrupt Int_ModeJump
> FADE OUT
- irq: Int_ModeJump(mode NewGame)
    - InitGameGraphics
    - set_level 1
    - set_mode SetupLevel
- irq: Int_ModeJump (mode SetupLevel)
  - SetupPlayer
  - set_mode WorldUpdate
- irq: Int_ModeJump (mode WorldUpdate)
  - update characters/scroll
  - DrawLevelToOffscreen
  - RequestWorldScreenUpdate
< FADE IN
- irq: Int_WorldScreenUpdate
  - copy everything to screen
  - set interrupt back to Int_ModeJump

To add:
  Int_WorldScreenUpdate - check fade mode, act appropriately
Frame 0: do world update
Frame 1: draw world

Fade out:
Init:
  - copy color RAM, sprite/bg colors into offscreen color area
Loop:
  - copy offscreen color to color RAM, copy sprite/bg colors
  - fade out 1 shade on offscreen color area

Fade in:
Init:
  - start with all offscreen colors black
  - copy desired chars onto screen
Loop:
  - copy offscreen color to color RAM
  - fade in 1 shade to offscreen color area


FADE ROUTINE(method 0)
; use offscreen char area to store target colors
; COLOR_FADE_TABLE: 16 values set up depending on the current fade_table_index(prior to loop)
  ldy offscreen_char,x
  lda COLOR_FADE_TABLE,y
  tay
  sta offscreen_color,x


FADE ROUTINE(method 1)
; COLOR_FADE_TABLE: rows=target color, columns=fade colors
;                       values: high nibble = color target, low nibble = cur value
; offscreen_color: high nibble = color target, low nibble = current value
  clc

  lda offscreen_color,x         ; 4-5
  and #$F0                      ; 2
  lsr                           ; 2  put in multiples of 8 for index into color table
  adc fade_table_index                ; 3  (0-7)
  tay                           ; 2
  lda COLOR_FADE_TABLE,y        ; 4-5
  sta offscreen_color,x         ; 4-5


FADE ROUTINE(method 2)
; COLOR_FADE_TABLE: 16 values set up depending on the current fade_table_index(prior to loop)
;                       values: high nibble = color target, low nibble = cur value
; offscreen_color: high nibble = color target, low nibble = current value
  clc

  lda offscreen_color,x         ; 4-5
  lsr                           ; 2  put in multiples of 8 for index into color table
  lsr                           ; 2
  lsr                           ; 2
  lsr                           ; 2
  tay                           ; 2
  lda COLOR_FADE_TABLE,y        ; 4-5
  sta offscreen_color,x         ; 4-5

FADE ROUTINE(method 3)
; COLOR_FADE_TABLE: rows=fade index(0-7), columns=current color value per target color
; offscreen_color: high nibble = color target, low nibble = current value
  clc
  ldx fade_table_index                ; fade_table_index is a multiple of 16 for each row
                                ;  of COLOR_FADE_TABLE

  lda offscreen_color,x
  and #$F0
  sta color_nibble              ; zp
  lsr                           ; put in multiples of 8 for index into color table
  lsr
  lsr
  lsr
  adc fade_table_index                ; (0-7)
  tay
  lda COLOR_FADE_TABLE,y
  ora color_nibble
  sta offscreen_color,x



aaaacccc
37


