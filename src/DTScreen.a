; "Downtown"
;(c) 2002 by Eric Odland
;
; File : DTScreen.a
;
; Contains : General Screen subroutines
;
;
; ZeroPage locations used:
;

;Colors
black           EQU 0
white           EQU 1
red             EQU 2
cyan            EQU 3
purple          EQU 4
green           EQU 5
blue            EQU 6
yellow          EQU 7
orange          EQU 8
brown           EQU 9
lred            EQU 10
grey1           EQU 11
grey2           EQU 12
lgreen          EQU 13
lblue           EQU 14
grey3           EQU 15

;IRQ Screen Update Compare
SUCompare       EQU 250
;IRQ ModeJump Compare Raster Line
MJCompare       EQU 100
;IRQ MainMenu Compare
MMCompare       EQU 255


; ******************* ClearScreen *******************
;
; Purpose:              Clear the current screen
;
; Registers used:       .A, .X
;
; How to use:
;       Call this routine.
;
ClearScreen     subroutine
        lda VICMEM      ; what screen are we on?
        and #%11110000
        lsr
        lsr
        clc
        adc #>VIC_BANK_START_LOC
        pha         ; store screen memory MSB
        tax
        stx .1+2
        inx
        stx .2+2
        inx
        stx .3+2
        stx .4+2

        ldx #0
        lda #SpaceBar
.1      sta $0400,x  ; these base addresses get set above based on VIC bank and
.2      sta $0500,x  ;   current screen mem bank
.3      sta $0600,x
.4      sta $06E9,x
        dex
        bne .1
        ;lda #$04        ; reset cursor to top of screen memory
        pla             ; recall screen memory MSB
        ;lda #>Screen1        ; reset cursor to top of screen memory
        stx CursorPos
        sta CursorPos+1
        lda #>COLORMEM        ; reset corresponding color memory
        stx ColorPos
        sta ColorPos+1
        rts

; ******************* ClearColors *******************
;
; Purpose:              Clear color memory from $D800-$D8E8
;
; Registers used:       .A, .X
;
; How to use:
;       Call this routine.
;
ClearColors     subroutine
        ldx #0
        txa
.1      sta COLORMEM,x
        sta COLORMEM+$100,x
        sta COLORMEM+$200,x
        sta COLORMEM+$2E9,x
        dex
        bne .1
        rts

; ******************* SMPlot *******************
;
; Purpose:              plot cursor at specified row/position
;
; Registers used:       .A, .X, .Y
;
; Memory used:          CursorPos (ZP)
;
; How to use:
;       Load .X/.Y with row/column of desired position
;       Call this routine.
;
SMPlot  subroutine
        ;lda #$04        ; reset cursor and color pos to top-left
        lda #>Screen1  ; reset cursor and color pos to top-left
        sta CursorPos+1
        lda #>COLORMEM
        sta ColorPos+1
        lda #$00
        sta CursorPos
        sta ColorPos
.1      dex     ; find screen position of row .X
        bmi .2
        clc
        adc #SCREEN_WIDTH
        bcc .1
        inc CursorPos+1
        inc ColorPos+1
        bcs .1  ; branch always
.2      sta CursorPos   ; add column .Y to cursor/color locations
        sta ColorPos
        tya
        clc
        adc CursorPos
        bcc .3
        inc CursorPos+1
        inc ColorPos+1
.3      sta CursorPos
        sta ColorPos
        rts


; ******************* SetCursorColor *******************
;
; Purpose:              set character color
;
; Registers used:       .A
;
; Memory used:          CursorColor
;
; How to use:
;       Load .A with desired color. Call this routine.
;
SetCursorColor  subroutine
        sta CursorColor
        rts


; ******************* ScreenUpdate *******************
;
; Purpose:              update the screen
;
; Registers used:       .A, .X, .Y
;
; Memory Used:          Temp, Temp+1, Temp2
;
; How to use:
;       Set IRQ vector to point here
;       Load .A with the first character.
;       Load .X with the width in chars.
;       Load .Y with the height.
;
ScreenUpdate    subroutine
        ;ldy #39
        ;inc $d020
        ;inc $d020


        ; Copy offscreen color info to color memory
        ;This ugly looking piece is simply an unrolled loop, for ultra-fast
        ;  processing
        ldy #(SCREEN_WIDTH-1)           ; for 40 screen columns
.1      lda OffscreenColor,y            ; 4
        sta COLORMEM,y                  ; 4-5
        lda OffscreenColor+40,y         ; 4
        sta COLORMEM+40,y               ; 4-5
        lda OffscreenColor+40*2,y       ; 4
        sta COLORMEM+40*2,y             ; 4-5
        lda OffscreenColor+40*3,y       ; 4
        sta COLORMEM+40*3,y             ; 4-5
        lda OffscreenColor+40*4,y       ; 4
        sta COLORMEM+40*4,y             ; 4-5
        lda OffscreenColor+40*5,y       ; 4
        sta COLORMEM+40*5,y             ; 4-5
        lda OffscreenColor+40*6,y       ; 4
        sta COLORMEM+40*6,y             ; 4-5
        lda OffscreenColor+40*7,y       ; 4
        sta COLORMEM+40*7,y             ; 4-5
        lda OffscreenColor+40*8,y       ; 4
        sta COLORMEM+40*8,y             ; 4-5
        lda OffscreenColor+40*9,y       ; 4
        sta COLORMEM+40*9,y             ; 4-5
        lda OffscreenColor+40*10,y      ; 4
        sta COLORMEM+40*10,y            ; 4-5
        lda OffscreenColor+40*11,y      ; 4
        sta COLORMEM+40*11,y            ; 4-5
        lda OffscreenColor+40*12,y      ; 4
        sta COLORMEM+40*12,y            ; 4-5
        lda OffscreenColor+40*13,y      ; 4
        sta COLORMEM+40*13,y            ; 4-5
        lda OffscreenColor+40*14,y      ; 4
        sta COLORMEM+40*14,y            ; 4-5
        lda OffscreenColor+40*15,y      ; 4
        sta COLORMEM+40*15,y            ; 4-5
        lda OffscreenColor+40*16,y      ; 4
        sta COLORMEM+40*16,y            ; 4-5
        lda OffscreenColor+40*17,y       ; 4
        sta COLORMEM+40*17,y            ; 4-5

        dey
        bpl .1

        ;   scroll screen to fine X dot position
        ; scanline moving into play area view, set scroll
        lda VIC2       ; vic control register
        and #%11111000  ; clear low 3 bits
        ora FineScroll  ; set low 3 bits to scroll value
        sta VIC2

        ; perform page-flip
        jsr PageFlip

        ; copy sprite pointers to screen memory
        ;ldx #$07                ; if page=1, use screen $0400
        ldx #>SCREEN_1_SPR_PTRS                ; if page=1
        ;lda Page                ; if page=0, use screen $2F00
        lda Page                ; if page=0
        bne .usp1
        ldx #>SCREEN_2_SPR_PTRS
.usp1   stx .spr+2
        ldx #<SPRDATA_OFFSET
        stx .spr+1
        ldx #7                  ; copy
.usp2   lda o_info,x            ; carry = facing bit
        lsr
        lsr
        lda S_spriteDataPtr,x
        adc #0                  ; add carry to .A (facing bit)
.spr    sta $FFFF,x
        dex
        bpl .usp2

        ; position sprites
        ldx #16                 ; the 16th index is the sprite X MSBs
.ps1    lda S_XYPos,x
        sta SPR0X,x
        dex
        bpl .ps1

        ; enable/disable sprites
        lda S_enable
        sta SPRDISP


        ; set interrupt back to ModeJump
        lda #MJCompare
        sta IRQ
        set_interrupt #ModeJump
        jmp ModeExit


;PrepareNextInterrupt   subroutine
;       set_interrupt VProgramLoopInterrupt
;       lda NextIRQCompare
;       sta $D012
;       rts
