; "Downtown"
;(c) 2002 by Eric Odland
;
; File : DTObjects.a
;
; Contains : Routines for creating and maintaining objects
;


; ******************* DATA *******************
;
kSpriteGroundLevel = 164        ; y position of sprites on ground level
kRunSpeed = 5                   ; the speed at which characters run
;
;;Actions
run = 0
jump = 1
land = 2
stand = 3
attack = 4
die = 5
beingHit = 6
;
;facings
right = %00000000
left = %00000010


object_record:          ; object records 0-7
; record Object {
;       byte info;      // Bit 0: active or inactive
;                       // Bit 1: facing(0=right)
;                       // Bit 2: newAction (whether a new action started)
;                       //    other bits depend on what type of object
;       byte type;
;       byte currentAction;
;       byte acceleration, velocity;
;       ptr  actionArray;// points to the array of sprite data ptrs for various
;                        //    actions
;       byte extraInfo;   // extra info dependent of what type of object
; };
o_info:
        DS.B 8
o_type:
        DS.B 8
o_currentAction:
        DS.B 8
;o_acceleration:
;       DS.B 8
o_velX:
        DS.B 8
o_velY:
        DS.B 8
o_actionArrayLo:
        DS.B 8
o_actionArrayHi:
        DS.B 8
o_extraInfo:
        DS.B 8



; ******* Object Definitions ********
;  defines what sprite data block to begin certain actions
;  for characters:
;       0 - run, 1 - jump, 2 - land, 3 - stand, 4 - attack,
;       5 - die, 6 - beingHit
ObjectPlayer:
        DC.B 85, 83, 83, 83, 83, 83, 83



; ******************* CODE *******************
;
; ******************* SetupPlayer *******************
;
; Purpose:              Setup player in sprite 0
;
; Registers used:
;
; How to use:
;       Call this routine when a level begins
;
SetupPlayer     subroutine
        jsr GenerateObject
        DC.B 0                  ; info
        DC.B 0                  ; type (0=player)
;       DC.B 3                  ; 3 = standing
        DC.B 0                  ; 0 = running
        DC.B 0                  ; velX = 0
        DC.B 0                  ; velY = 0
        DC.W ObjectPlayer       ; points to action array
        DC.B 0                  ; no extra info
        DC.B 0                  ; color
        DC.B kSpriteGroundLevel ; YPos = 164
        DC.W 160                ; XPos = 160
        DC.B 0                  ; Sprite 0

        ;ldx #0
        ;lda #run
        ;ldy #right
        ;jsr RequestAction

        ; get current action
        ldx #0
        lda o_actionArrayLo,x
        ldy o_actionArrayHi,x
        sta temp_w
        sty temp_w+1
        lda o_currentAction,x
        tay
        lda (temp_w),y            ; check sprite's image
        ldy #0                  ; set sprite data ptr accordingly
        sta S_spriteDataPtr,y
        rts


; ******************* GenerateObject *******************
;
; Purpose:              Creates an object with specified characteristics
;
; Registers used:
;
; How to use:
;       Make sure required data follows your JSR instruction in this order:
;               info, type, currentAction, acceleration, velocity,
;               actionArray, extraInfo, color, YPos, XPos, XMSB,
;               objectIndex(0-7)
;       Call this routine when a level begins
;
; FIXME: create constants for all the indexes into an object record
GenerateObject  subroutine
        pla                     ; get return address(points to data following
        sta temp_w                ;   the JSR)
        pla
        sta temp_w+1
        inc temp_w                ; add 1 to pointer
        bne .add
        inc temp_w+1
.add:

        ldy #12                 ; what is object's index?(0-7)
        lda (temp_w),y
        tax                     ; store in x for later

        ; copy data into object record
        ;   (used by WorldUpdate)
        ldy #0
        lda (temp_w),y
        ora #1                  ; set bit 0 to 1.(active object)
        sta o_info,x
        iny
        lda (temp_w),y
        sta o_type,x
        iny
        lda (temp_w),y
        sta o_currentAction,x
        iny
        lda (temp_w),y
        sta o_velX,x
        iny
        lda (temp_w),y
        sta o_velY,x
        iny
        lda (temp_w),y
        sta o_actionArrayLo,x
        iny
        lda (temp_w),y
        sta o_actionArrayHi,x
        iny
        lda (temp_w),y
        sta o_extraInfo,x


        ; set sprite color
        ldy #8
        lda (temp_w),y
        sta SPR0C,x

        ; copy data into sprite record
        ;   (setup by WorldUpdate, copied to
        ;    VIC memory by Int_WorldScreenUpdate)
        lda kResetBit,x         ; initially reset X MSB
        and S_XMSB
        sta S_XMSB
        ldy #11                 ; get X MSB
        lda (temp_w),y
        lsr
        bcc .out1
        lda kSetBit,x           ; set sprite's X MSB bit
        ora S_XMSB
        sta S_XMSB
.out1:
        ; enable the sprite
        lda kSetBit,x
        ora S_enable
        sta S_enable

        ; copy X and Y positions
        txa                     ; X = X * 2
        asl
        tax
        dey                     ; get X pos
        lda (temp_w),y
        sta S_XYPos,x
        dey                     ; get Y pos
        lda (temp_w),y
        inx
        sta S_XYPos,x

        ; set return address to instruction after data
        lda temp_w                ; A = (temp_w)+12
        clc
        adc #12
        tax                     ; X = A
        lda temp_w+1              ; A = (temp_w+1)+C
        adc #0
        pha
        txa
        pha

        rts

; ******************* RequestAction *******************
;
; Purpose:              requests that a character begin a certain action
;                       (for actions, see "Actions," above)
; Registers used:
;
; How to use:
;       Load .X with the object to request (0-7)
;       Load .A with the desired action (run, stand, attack, jump)
;       Load .Y with the desired facing (left or right)
;       Call this routine
;
RequestAction   subroutine
        sta temp_w                ; temp_w = desired action
        lda o_currentAction,x   ; if action already being done, return
        sta temp_w2               ;  temp2 = current action
        cmp temp_w                ;
        bne .newact             ;
        lda o_info,x            ; if facing different, update action
        and #%00000010
        sta temp_w3
        cpy temp_w3
        beq .exit
.newact tya
        ldy temp_w                ; action = run?
        bne .1

        ; run
        tay                     ; .Y = desired facing
        lda temp_w2
        cmp #stand              ;   if not standing or running,
                                ;       can't run(go exit)
        beq .run1               ;
        cmp #run                ;
        bne .exit               ;
.run1   ;lda o_info,x
        ;pha                    ; store current info
        ;and #%11111101
        ;and #%00000010         ; check facing
        ;sta temp_w3              ; temp_w3 = current facing
        ;cpy temp_w3
        ;bne .face              ; can't start run again in same direction!

        ;jmp .exit
        ;pha
        ;lda temp_w2
        ;cmp #run
        ;beq .exit
        ;pla
.face   ;pla                    ; set current facing to desired facing
        and #%11111101
        sty temp_w3
        ora temp_w3
        sta o_info,x
        lda #kRunSpeed          ; set velocity
        cpy #right              ;  positive if facing right
        beq .rt                 ;
        lda #(-kRunSpeed)       ;  negative if facing left
.rt     sta o_velX,x            ;
        jmp .setAction

.1
        dey                     ; action = jump?
        bne .2

        ; jump
        lda temp_w2
        cmp #attack
        beq .exit
        cmp #jump
        beq .exit
        lda #(-8)               ; set jump velocity
        sta o_velY,x
        jmp .setAction

.2      dey
        dey                     ; action = stand?
        bne .3

        ; stand
        lda #0
        sta o_velX,x
        jmp .setAction

.3      dey                     ; action = attack?
        bne .exit

        ; attack

.setAction:
; called if the action has been granted
        lda o_info,x            ; newAction = true
        ora #%00000100          ;
        sta o_info,x
        lda temp_w
        tay                     ; y = theAction
        sta o_currentAction
        lda o_actionArrayLo,x
        sta temp_w
        lda o_actionArrayHi,x
        sta temp_w+1
        lda (temp_w),y            ; set sprite data pointer based on action
        sta S_spriteDataPtr,x


.exit   rts
;       0 - run, 1 - jump, 2 - land, 3 - stand, 4 - attack,
;       5 - die, 6 - beingHit

; ******************* DisableSprite *******************
;
; Purpose:              Disables sprite
;
; Registers used:
;
; How to use:
;       Load .X with the object to disable (0-7)
;       Call this routine
;
DisableSprite   subroutine
        lda kResetBit,x
        and S_enable
        sta S_enable
        rts

